import numpy as np
import warnings
from openmdao.api import ExplicitComponent
from openmdao.api import Group

class FuelCellPEM(Group):
    """
    This is a model of a Polymer Electrolyte Membrane (PEM) Fuel Cell.  It is primarily based on the book "Fuel Cell Fundementals" by O'Hayre et. al. (2016), 
    beginning on page 219, with a few modifications.  It is a 1D model with a number of simplifying assumptions, but represents the highest 
    available fidelity without moving to CFD analysis.  The most critical assumption is that of j_L, or the limit current density, which sets 
    the shape of the voltage vs. current density curves.  This value should in theory be set by the cathode thickness, which is highly dependent 
    on the state of modern technology.

    Additionaly, the mass model here depends on two critical constants A and B, which are entirely empirical and should not be trusted for 
    work on real engineering applications.  At a minimum, we recommend studying the effects of varying these parameters.  

    There is an assumed DC-DC conversion step since most fuel cells are not designed to produce the desired output voltage.

    User should beware that locking in a ratedPower value is likely unwise, and this should be treated as a lower bound constraint, ie
    ratedPower >= someLowerBound.  This is because designing the cell for a higher rated power than necessary will increase the mass, but
    may also significantly improve operating efficiency at the design point.  Since weight impacts fuel burn by a log, and efficiency linearly,
    there will be some tradeoff here.  

    There are a number of exposed options, which we as the modelers expect will want to be varied by the end user.  However, there are a 
    number of hidden options in the self.setup function which also may be of interest to the expert user.

    Inputs
    ------
    pressure : float
        Operating pressure of the fuel cell.  This model does not account
        for a compressor to rais the operating pressure from ambient.
        (scalar, atmospheres)
    temperature : float
        Operating temperature of the fuel cell.
        (scalar, Kelvin)
    area : float
        Working area of the fuel cell
        (scalar, m)
    throttle : float
        Engine throttle. Scales current density based on the internally 
        computed maximum current density value.  Produces 100% of rated 
        power at throttle = 1.  Should be in range 0 to 1
        (vector, dimensionless)

    Outputs
    -------
    mdot_H2 : float
        Mass consumption of hydrogen, ie fuel flow
        (vector, kg/s)
    mdot_O2 : float
        Mass consumption of oxygen, sets inlet requirements
        (vector, kg/s)
    mdot_Air : float
        Mass consumption of air based on the mass fraction of oxygen
        (vector, kg/s) 
    eps_total : float
        Fuel cell efficiency
        (vector, dimensionless)
    power : float
        Electrical power generated by the fuel cell
        (vector, Watts)
    usablePower : float
        Power available after DC-DC conversion
        (vector, Watts)
    usableHeat : float
        Heat generated by the fuel cell and the DC-DC converter
        (vector, Watts)
    heat : float
        Heat generated by the fuel cell 
        (vector, Watts)

    Options
    -------
    num_nodes : int
        Number of analysis points to run (sets vec length; default 1)
    n_samples : int
        Number of samples used in finding the j_max value
        (default 1000)
    j_L : float
        Limit current density, primarily driven by the thickness of the
        cathode
        (default 2.0, A/cm**2)
    A : float
        Mass coefficient for the area based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 0.5, kg/m**2)
    B : float   
        Mass coefficient for the rated power based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 15.0, kg/W)
    eta_dcdc : float
        Conversion efficiency of the expected DC-DC converter.  The heat from 
        this conversion is included in the usable heat output.
        (default 0.9, dimensionless)

    """

    def initialize(self):
        self.options.declare("num_nodes"   , default=1           , desc = "Number of flight/control conditions")
        self.options.declare("n_samples"   , default=1000        , desc = "Number of samples to take in finding j_max")

        # Very likely to change:
        self.options.declare("j_L"         , default = 2.0       , desc = "Limit currrent density [A/cm**2]")
        self.options.declare("A"           , default = 0.5       , desc = "Mass coefficient for area [kg/m**2]")
        self.options.declare("B"           , default = 15.0      , desc = "Mass coefficient for rated power [kg/W]")
        self.options.declare("eta_dcdc"    , default = 0.9       , desc = "Limit currrent density [A/cm**2]")

        # # Likely to change:
        # self.options.declare("t_M"         , default = 20e-6     , desc = "Membrane thickness [m]")
        
        # # May Change:
        # self.options.declare("E_thermo"    , default = 1.06      , desc = "Thermodynamic voltage [V]")
        # self.options.declare("DeltaG_act"  , default = 100e3     , desc = "Electrolyte activation energy [J/mol]")
        # self.options.declare("alpha"       , default = 0.5       , desc = "Transfer coefficient")                    # Range: 0.2-0.5
        # self.options.declare("j0"          , default = 0.1       , desc = "Exchange current density [A/cm**2]")
        # self.options.declare("eps"         , default = 0.4       , desc = "Porosity")                                # Range: 0.4
        # self.options.declare("tau"         , default = 1.5       , desc = "Tortuosity")                              # Range: 1.5-10
        
        # # Should not change
        # self.options.declare("R"           , default = 8.314     , desc = "Gas constant [J/(mol*K)]")
        # self.options.declare("F"           , default = 96485.34  , desc = "Faraday constant [C/mol]")
        # self.options.declare("x_O2d"       , default = 0.21      , desc = "Oxygen inlet mole fraction")

    def setup(self):
        hidden_options_dict = {
                                    "t_M"         : 125e-6,
                                    "t_A"         : 350e-6,
                                    "t_C"         : 350e-6,
                                    "E_thermo"    : 1.20,
                                    "D_lam"       : 3.81e-6 * 10000,
                                    "alpha"       : 0.5,
                                    "j0"          : 0.0001,
                                    "eps"         : 0.4,
                                    "tau"         : 1.5,
                                    "R"           : 8.314,
                                    "F"           : 96485.34,
                                    "x_H2"        : 1.0,
                                    "x_O2"        : 0.19,
                                    "x_H2O"       : 0.1,
                              }

        jmax_dict     = {"n_samples":self.options["n_samples"],
                         "j_L":self.options["j_L"] } | hidden_options_dict

        sizing_dict   = {"j_L":self.options["j_L"], 
                         "A":self.options["A"], 
                         "B":self.options["B"], 
                         "eta_dcdc":self.options["eta_dcdc"]} | hidden_options_dict

        analysis_dict = {"num_nodes":self.options["num_nodes"],
                         "j_L":self.options["j_L"], 
                         "A":self.options["A"], 
                         "B":self.options["B"], 
                         "eta_dcdc":self.options["eta_dcdc"]} | hidden_options_dict

        self.add_subsystem("ComputeDiffusivity_O2N2", 
                           ComputeDiffusivity(medium1="O2", medium2="N2"))
        
        self.add_subsystem("ComputeDiffusivity_H2H2O", 
                           ComputeDiffusivity(medium1="H2", medium2="H2O")) 

        self.add_subsystem("ComputeDiffusivity_O2H2O", 
                           ComputeDiffusivity(medium1="O2", medium2="H2O")) 

        self.add_subsystem("VaporSaturationPressure", 
                           BuckEquation(), 
                           promotes_inputs=["*"], promotes_outputs=["*"])

        self.add_subsystem("ComputeEpsThermo", 
                           ComputeEpsThermo(), 
                           promotes_inputs=["*"], promotes_outputs=["*"])

        self.add_subsystem("computeJMax", 
                           ComputeJMax(**jmax_dict), 
                           promotes_inputs=["*"], promotes_outputs=["*"])

        # self.add_subsystem("SOFCSizing", 
        #                    SOFCSizing(**sizing_dict), 
        #                    promotes_inputs=["*"], promotes_outputs=["*"])

        self.add_subsystem("PEMAnalysis", 
                           PEMAnalysis(**analysis_dict), 
                           promotes_inputs=["*"], promotes_outputs=["*"])


        self.connect("ComputeDiffusivity_O2N2.diffusivity","diffusivity_O2N2")
        self.connect("ComputeDiffusivity_H2H2O.diffusivity","diffusivity_H2H2O")
        self.connect("ComputeDiffusivity_O2H2O.diffusivity","diffusivity_O2H2O")


class FuelCellPEM_RatedPower(Group):
    """
    This is a model that predicts the rated power of a Polymer Electrolyte Membrane (PEM) Fuel Cell. 

    Inputs
    ------
    pressure : float
        Operating pressure of the fuel cell.  This model does not account
        for a compressor to rais the operating pressure from ambient.
        (scalar, atmospheres)
    temperature : float
        Operating temperature of the fuel cell.
        (scalar, Kelvin)
    area : float
        Working area of the fuel cell
        (scalar, m)
    throttle : float

    Outputs
    -------
    ratedPower : float
        The maximum output power of the fuel cell
        (scalar, W)


    Options
    -------
    n_samples : int
        Number of samples used in finding the j_max value
        (default 1000)
    j_L : float
        Limit current density, primarily driven by the thickness of the
        cathode
        (default 2.0, A/cm**2)
    eta_dcdc : float
        Conversion efficiency of the expected DC-DC converter.  The heat from 
        this conversion is included in the usable heat output.
        (default 0.9, dimensionless)

    """

    def initialize(self):
        self.options.declare("num_nodes"   , default=1           , desc = "Number of flight/control conditions")
        self.options.declare("n_samples"   , default=1000        , desc = "Number of samples to take in finding j_max")

        # Very likely to change:
        self.options.declare("j_L"         , default = 2.0       , desc = "Limit currrent density [A/cm**2]")
        # self.options.declare("A"           , default = 0.5       , desc = "Mass coefficient for area [kg/m**2]")
        # self.options.declare("B"           , default = 15.0      , desc = "Mass coefficient for rated power [kg/W]")
        self.options.declare("eta_dcdc"    , default = 0.9       , desc = "Limit currrent density [A/cm**2]")

        # # Likely to change:
        # self.options.declare("t_M"         , default = 20e-6     , desc = "Membrane thickness [m]")
        
        # # May Change:
        # self.options.declare("E_thermo"    , default = 1.06      , desc = "Thermodynamic voltage [V]")
        # self.options.declare("DeltaG_act"  , default = 100e3     , desc = "Electrolyte activation energy [J/mol]")
        # self.options.declare("alpha"       , default = 0.5       , desc = "Transfer coefficient")                    # Range: 0.2-0.5
        # self.options.declare("j0"          , default = 0.1       , desc = "Exchange current density [A/cm**2]")
        # self.options.declare("eps"         , default = 0.4       , desc = "Porosity")                                # Range: 0.4
        # self.options.declare("tau"         , default = 1.5       , desc = "Tortuosity")                              # Range: 1.5-10
        
        # # Should not change
        # self.options.declare("R"           , default = 8.314     , desc = "Gas constant [J/(mol*K)]")
        # self.options.declare("F"           , default = 96485.34  , desc = "Faraday constant [C/mol]")
        # self.options.declare("x_O2d"       , default = 0.21      , desc = "Oxygen inlet mole fraction")

    def setup(self):
        hidden_options_dict = {
                                    "t_M"         : 125e-6,
                                    "t_A"         : 350e-6,
                                    "t_C"         : 350e-6,
                                    "E_thermo"    : 1.20,
                                    "D_lam"       : 3.81e-6 * 10000,
                                    "alpha"       : 0.5,
                                    "j0"          : 0.0001,
                                    "eps"         : 0.4,
                                    "tau"         : 1.5,
                                    "R"           : 8.314,
                                    "F"           : 96485.34,
                                    "x_H2"        : 1.0,
                                    "x_O2"        : 0.19,
                                    "x_H2O"       : 0.1,
                              }

        jmax_dict     = {"n_samples":self.options["n_samples"],
                         "j_L":self.options["j_L"] } | hidden_options_dict

        sizing_dict   = {"j_L":self.options["j_L"], 
                         # "A":self.options["A"], 
                         # "B":self.options["B"], 
                         "eta_dcdc":self.options["eta_dcdc"]} | hidden_options_dict

        analysis_dict = {#"num_nodes":self.options["num_nodes"],
                         "j_L":self.options["j_L"], 
                         # "A":self.options["A"], 
                         # "B":self.options["B"], 
                         "eta_dcdc":self.options["eta_dcdc"]} | hidden_options_dict

        self.add_subsystem("ComputeDiffusivity_O2N2", 
                           ComputeDiffusivity(medium1="O2", medium2="N2"))
        
        self.add_subsystem("ComputeDiffusivity_H2H2O", 
                           ComputeDiffusivity(medium1="H2", medium2="H2O")) 

        self.add_subsystem("ComputeDiffusivity_O2H2O", 
                           ComputeDiffusivity(medium1="O2", medium2="H2O")) 

        self.add_subsystem("VaporSaturationPressure", 
                           BuckEquation(), 
                           promotes_inputs=["*"], promotes_outputs=["*"])

        self.add_subsystem("ComputeEpsThermo", 
                           ComputeEpsThermo(), 
                           promotes_inputs=["*"], promotes_outputs=["*"])

        self.add_subsystem("computeJMax", 
                           ComputeJMax(**jmax_dict), 
                           promotes_inputs=["*"], promotes_outputs=["*"])

        # self.add_subsystem("SOFCSizing", 
        #                    SOFCSizing(**sizing_dict), 
        #                    promotes_inputs=["*"], promotes_outputs=["*"])

        self.add_subsystem("PEMRatedPowerAnalysis", 
                           PEMRatedPowerAnalysis(**analysis_dict), 
                           promotes_inputs=["*"], promotes_outputs=["*"])


        self.connect("ComputeDiffusivity_O2N2.diffusivity","diffusivity_O2N2")
        self.connect("ComputeDiffusivity_H2H2O.diffusivity","diffusivity_H2H2O")
        self.connect("ComputeDiffusivity_O2H2O.diffusivity","diffusivity_O2H2O")



class ComputeDiffusivity(ExplicitComponent):
    """
    This is a model for the binary diffusion coefficient based on the book "Fuel Cell Fundementals" by O'Hayre et. al. (2016), page 173.
    It supports the media: H2, Air, N2, O2, CO, CO2, and H2O.  The model is dependent on temperature and pressure.

    Inputs
    ------
    pressure : float
        Ambient pressure
        (scalar, atmospheres)
    temperature : float
        Ambient temperature
        (scalar, Kelvin)

    Outputs
    -------
    diffusivity : float
        Binary diffusion coefficient between the two media
        (scalar, m**2/s)

    Options
    -------
    medium1 : str
        The first medium
        (default "O2")
    medium2 : str
        The second medium
        (default "N2")

    """

    def initialize(self):
        self.options.declare("medium1", default="O2" , desc = "Diffusion Medium 1")
        self.options.declare("medium2", default="N2" , desc = "Diffusion Medium 2")
        
    def setup(self):
        self.add_input("pressure"    , units="atm" , desc = "Fuel cell pressure")
        self.add_input("temperature" , units="K"   , desc = "Fuel cell temperature")

        self.add_output("diffusivity", units="m**2/s", desc = "Diffusivity")

        self.declare_partials('*', '*', method='cs')

    def compute(self, inputs, outputs):
        p = inputs["pressure"]
        T = inputs["temperature"]

        medium1 = self.options["medium1"]
        medium2 = self.options["medium2"]

        if medium1 not in ["H2","Air","N2","O2","CO","CO2","H2O"]:
            raise ValueError("Invalid Medium for Diffusion")

        if medium2 not in ["H2","Air","N2","O2","CO","CO2","H2O"]:
            raise ValueError("Invalid Medium for Diffusion")

        if 'H2O' not in [medium1, medium2]:
            a = 2.7445e-4
            b = 1.823
        else:
            a = 3.640e-4
            b = 2.334
        
        tbl = {}
        tbl['H2'] = {}
        tbl['H2']['M']  = 2.016
        tbl['H2']['Tc'] = 33.3
        tbl['H2']['pc'] = 12.80
        tbl['Air'] = {}
        tbl['Air']['M']  = 28.964
        tbl['Air']['Tc'] = 132.4
        tbl['Air']['pc'] = 37.0
        tbl['N2'] = {}
        tbl['N2']['M']  = 28.013
        tbl['N2']['Tc'] = 126.2
        tbl['N2']['pc'] = 33.5
        tbl['O2'] = {}
        tbl['O2']['M']  = 31.999
        tbl['O2']['Tc'] = 154.4
        tbl['O2']['pc'] = 49.7
        tbl['CO'] = {}
        tbl['CO']['M']  = 28.010
        tbl['CO']['Tc'] = 132.9
        tbl['CO']['pc'] = 34.5
        tbl['CO2'] = {}
        tbl['CO2']['M']  = 44.010
        tbl['CO2']['Tc'] = 304.2
        tbl['CO2']['pc'] = 72.8
        tbl['H2O'] = {}
        tbl['H2O']['M']  = 18.015
        tbl['H2O']['Tc'] = 647.3
        tbl['H2O']['pc'] = 217.5
        
        Tci = tbl[medium1]['Tc']
        Tcj = tbl[medium2]['Tc']
        pci = tbl[medium1]['pc']
        pcj = tbl[medium2]['pc']
        Mi  = tbl[medium1]['M']
        Mj  = tbl[medium2]['M']
        
        D_ij = (1/p) * a * (T/(Tci*Tcj)**0.5)**b * (pci*pcj)**(1/3) * (Tci*Tcj)**(5/12) * (1/Mi + 1/Mj)**0.5

        #formula is in cm**2/s and needs to be corrected
        D_ij/=10000

        outputs["diffusivity"] = D_ij


class ComputeEpsThermo(ExplicitComponent):
    """
    This is a model for the maximum theoretical fuel cell efficiency based on the book "Fuel Cell Fundementals" 
    by O'Hayre et. al. (2016), Chapter 2.  

    Inputs
    ------
    temperature : float
        Ambient temperature
        (scalar, Kelvin)

    Outputs
    -------
    eps_thermo : float
        Max theoretical efficiency of the fuel cell
        (scalar, dimensionless)

    """

    def initialize(self):
        pass

    def setup(self):
        self.add_input("temperature", units="K", desc = "Fuel cell temperature")

        self.add_output("eps_thermo",  desc = "Max theoretical thermo efficiency")

        self.declare_partials('*', '*', method='cs')

    def compute(self, inputs, outputs):
        T = inputs["temperature"]
        # (kJ/mol)
        Delta_h0_H2O_g = -241.83
        Delta_h0_H2O_l = -285.83
        Delta_h0_H2    = 0.00
        Delta_h0_O2    = 0.00

        Delta_h0_g = Delta_h0_H2O_g - (Delta_h0_H2 + 0.5*Delta_h0_O2)
        Delta_h0_l = Delta_h0_H2O_l - (Delta_h0_H2 + 0.5*Delta_h0_O2)

        if T >= 373.15:
            # Reaction produces gaseous water
            Delta_h0 = Delta_h0_g
        else:
            # Reaction produces liquid water
            Delta_h0 = Delta_h0_l

        #(J/(mol*K))
        s0_H2O_g = 188.84
        s0_H2O_l = 69.95
        s0_H2    = 130.68
        s0_O2    = 205.00

        Delta_s0_g = s0_H2O_g - (s0_H2 + 0.5*s0_O2)
        Delta_s0_l = s0_H2O_l - (s0_H2 + 0.5*s0_O2)

        if T >= 373.15:
            # Reaction produces gaseous water
            Delta_s0 = Delta_s0_g
        else:
            # Reaction produces liquid water
            Delta_s0 = Delta_s0_l

        Delta_g = Delta_h0 - T*Delta_s0 / 1000 # need J to kJ correction

        # Delta_h_LHV = -241. # (kJ/mol), assumes gaseous water, do not use
        #  Would need to somehow extract the work from condensation, which is not realistic
        Delta_h_HHV = -285.83 # (kJ/mol), Assumes condensed water

        eps_thermo = Delta_g/Delta_h_HHV
        outputs["eps_thermo"] = eps_thermo

class BuckEquation(ExplicitComponent):
    """
    This is a model for vapor saturation pressure using the Buck equation from  "Fuel Cell Fundementals" 
    by O'Hayre et. al. (2016).  

    Inputs
    ------
    temperature : float
        Ambient temperature
        (scalar, Kelvin)

    Outputs
    -------
    p_SAT : float
        Vapor satuation pressure
        (scalar, Pa)

    """

    def initialize(self):
        pass

    def setup(self):
        self.add_input("temperature", units="K", desc = "Fuel cell temperature")

        self.add_output("p_SAT", units="Pa", desc = "Saturation pressure")

        self.declare_partials('*', '*', method='cs')

    def compute(self, inputs, outputs):
        T = inputs["temperature"]
        T = T - 273.15 # Convert to Celsius
        P = 0.61121 * np.exp((18.678-T/234.5)*(T/(257.14+T)))
        # P: vapor saturation pressure in Pa
        outputs["p_SAT"] = P*1000

class ComputeJMax(ExplicitComponent):
    """
    This is a model for determining the current density that provides the maximum power output based on the book "Fuel Cell Fundementals" 
    by O'Hayre et. al. (2016).  It computes a Power vs. Current Density curve that is sampled at discrete intervals between 0 and j_L,
    which is set as an option.  The number of samples is also an option.  

    Inputs
    ------
    pressure : float
        Ambient pressure
        (scalar, atmospheres)
    temperature : float
        Ambient temperature
        (scalar, Kelvin)
    diffusivity_O2N2 : float
        Binary diffusion coefficient for oxygen and nitrogen, comes from previous model
        (scalar, m**2/s)
    diffusivity_H2H2O : float
        Binary diffusion coefficient for hydrogen and water, comes from previous model
        (scalar, m**2/s)
    diffusivity_O2H2O : float
        Binary diffusion coefficient for oxygen and water, comes from previous model
        (scalar, m**2/s)
    p_SAT : float
        Vapor saturation pressure, comes from previous model
        (scalar, Pa)
    eps_thermo : float
        Max theoretical efficiency of the fuel cell, comes from previous model
        (scalar, dimensionless)

    Outputs
    -------
    j_max : float
        Current density that produces the maximum power
        (scalar, A/cm**2)

    Options
    -------
    n_samples : int
        Number of samples used in finding the j_max value
        (default 1000)
    j_L : float
        Limit current density, primarily driven by the thickness of the cathode
        (default 2.0, A/cm**2)
    A : float
        Mass coefficient for the area based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 0.5, kg/m**2)
    B : float   
        Mass coefficient for the rated power based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 15.0, kg/W)
    eta_dcdc : float
        Conversion efficiency of the expected DC-DC converter.  The heat from 
        this conversion is included in the usable heat output.
        (default 0.9, dimensionless)
    t_M : float
        Membrane thickness for the electrolyte passing material [m]
        (default 20e-6)
    t_A : float
        Annode thickness [m]
        (default 350e-6)
    t_C : float
        Cathode thickness [m]
        (default 350e-6)
    E_thermo : float
        Thermodynamic voltage, theoretical value that probably should not change [V]
        ( default 1.06 )     
    D_lam : float   
        Water diffusivity in Nafion [m**2/s]
        ( default 100e3 )    
    alpha : float       
        Transfer coefficient, ranges from 0.2 to 0.5
        ( default 0.5 )      
    j0 : float          
        Exchange current density [A/cm**2]
        ( default 0.1 )      
    eps : float         
        Porosity of the electrodes
        ( default 0.4 )      
    tau : float         
        Tortuosity of the electrodes, ranges from 1.5 to 10
        ( default 1.5 )      
    R : float           
        Gas constant [J/(mol*K)]
        ( default 8.314 )    
    F : float           
        Faraday constant [C/mol]
        ( default 96485.34 ) 
    x_H2 : float        
        Hydrogen mole fraction in the fuel
        ( default 1.0 )    
    x_O2 : float        
        Oxygen mole fraction
        ( default 0.19 )    
    x_H2O : float        
        Water mole fraction
        ( default 0.1 )       

    """
    def initialize(self):
        # Setup
        self.options.declare("n_samples"   , default = 1000       , desc = "Number of samples to find j_max")

        # Very likely to change:
        self.options.declare("j_L"         , default = 2.0       , desc = "Limit currrent density [A/cm**2]")

        # Likely to change:
        self.options.declare("t_M"         , default = 20e-6     , desc = "Membrane thickness [m]")
        self.options.declare("t_A"         , default = 350e-6    , desc = "Annode thickness [m]")
        self.options.declare("t_C"         , default = 350e-6    , desc = "Cathode thickness [m]")
        
        # May Change:
        self.options.declare("E_thermo"    , default = 1.06      , desc = "Thermodynamic voltage [V]")
        self.options.declare("D_lam"       , default = 3.81e-6 * 10000 , desc = "Water diffusivity in Nafion [m**2/s]")
        self.options.declare("alpha"       , default = 0.5       , desc = "Transfer coefficient")                    # Range: 0.2-0.5
        self.options.declare("j0"          , default = 0.1       , desc = "Exchange current density [A/cm**2]")
        self.options.declare("eps"         , default = 0.4       , desc = "Porosity")                                # Range: 0.4
        self.options.declare("tau"         , default = 1.5       , desc = "Tortuosity")                              # Range: 1.5-10
        
        # Should not change
        self.options.declare("R"           , default = 8.314     , desc = "Gas constant [J/(mol*K)]")
        self.options.declare("F"           , default = 96485.34  , desc = "Faraday constant [C/mol]")
        self.options.declare("x_H2"        , default = 1.0       , desc = "Hydrogen fuel mole fraction")
        self.options.declare("x_O2"        , default = 0.19      , desc = "Oxygen mole fraction")
        self.options.declare("x_H2O"       , default = 0.1       , desc = "Water mole fraction")

    def setup(self):
        # self.add_input("ratedPower"       , units="W"      , desc = "Rated Power")
        self.add_input("pressure"         , units="atm"    , desc = "Fuel cell pressure")
        self.add_input("temperature"      , units="K"      , desc = "Fuel cell temperature")
        self.add_input("diffusivity_O2N2" , units="m**2/s" , desc = "Diffusivity of oxygen and nitrogen")
        self.add_input("diffusivity_H2H2O", units="m**2/s" , desc = "Diffusivity of hydrogen and water")
        self.add_input("diffusivity_O2H2O", units="m**2/s" , desc = "Diffusivity of oxygen and water")
        self.add_input("p_SAT"            , units="Pa"     , desc = "Vapor saturation pressure")

        self.add_input("eps_thermo"       ,                  desc = "Max theoretical thermo efficiency")

        self.add_output("j_max", units="A/cm**2", desc = "Fuel cell current density at max power")

        self.declare_partials('*', '*', method='cs')

    def compute(self, inputs, outputs):
        p          = inputs["pressure"]
        T          = inputs["temperature"]
        D_ij_O2N2  = inputs["diffusivity_O2N2"]
        D_ij_H2H2O = inputs["diffusivity_H2H2O"]
        D_ij_O2H2O = inputs["diffusivity_O2H2O"]
        eps_thermo = inputs["eps_thermo"]
        p_SAT      = inputs["p_SAT"]

        j_L        = self.options["j_L"]
        t_M        = self.options["t_M"]
        t_A        = self.options["t_A"]
        t_C        = self.options["t_C"]
        E_thermo   = self.options["E_thermo"]
        D_lam      = self.options["D_lam"]
        alpha      = self.options["alpha"]
        j0         = self.options["j0"]
        eps        = self.options["eps"]
        tau        = self.options["tau"]
        R          = self.options["R"]
        F          = self.options["F"]
        x_H2       = self.options["x_H2"]
        x_O2       = self.options["x_O2"]
        x_H2O      = self.options["x_H2O"]

        D_eff_O2N2  = eps ** tau * D_ij_O2N2
        D_eff_H2H2O = eps ** tau * D_ij_H2H2O
        D_eff_O2H2O = eps ** tau * D_ij_O2H2O

        p_in_atms = p
        p_of_atm = 101325
        p_C = p_in_atms * p_of_atm
        p_A = p_in_atms * p_of_atm

        j_max = 0
        powerRate_prev = 0.0
        jarr = np.linspace(0,j_L,self.options["n_samples"])
        for j in jarr[1:]:
            a11 = 4.4 + 14 * (p_A / p_SAT) * (t_A * ( j*10000 * R * T )/(2*F*p_A*D_eff_H2H2O))
            a12 = 1.0
            b1  = 14 * (p_A / p_SAT) * x_H2O
            
            K = t_C * j*10000 * R * T / (4 * F * p_C * D_eff_O2H2O)
            pRat = p_C/p_SAT
            a21 = 4.4 + (4*pRat*K)
            a22 = np.exp(0.000598 * (j*10000/10000)*(t_M*100)/(D_lam/10000))
            b2  = 10.0 + 4*pRat*(x_H2O + K)
            
            alphaStar = (b1 - a12*b2/a22) / (a11-a12*a21/a22)
            C         = (b2-a21*alphaStar)/a22

            z = np.linspace(0,t_M*100,10000)
            lam = 4.4*alphaStar + C*np.exp(0.000598 * (j)*(z)/(D_lam/10000))
            sigma = (0.005193*lam - 0.003261)*np.exp(1268*(1/303-1/T))
            integrand = 1/sigma
            dz = z[1]-z[0]
            A_PEMFC=np.sum(dz*integrand)/10000

            eta_ohmic = j * 1e4 * A_PEMFC

            cr = x_O2*p_in_atms*p_of_atm/ R/T
            t_C = 4 * F * D_eff_O2N2 / j_L * cr/10000
            f_j = j/j_L
            if j == 0:
                eta_cathode = 0
            elif f_j>=1:
                eta_cathode = E_thermo
            else:
                eta_cathode =  R * T / (4 * alpha * F) * np.log( f_j*(4*F*D_eff_O2N2*p_of_atm/(t_C*R*T)) /(j0*10000*(1-f_j)))
            
            V = E_thermo - max([eta_ohmic,0]) - max([eta_cathode,0])
            
            n_H2 = 2  # H2 reaction rejects 2 electrons
            n_O2 = 4  # O2 reaction accepts 4 electrons
            
            molarMass_H2 = 2.016
            molarMass_O2 = 15.999
            massFraction_O2inAir = .2313333 # air is 23% oxygen by mass

            J_H2 = j/(n_H2*F)  # mol/s
            mdot_H2 = J_H2*molarMass_H2 # g/s
            
            J_O2 = j/(n_O2*F)  # mol/s
            mdot_O2 = J_O2*molarMass_O2 # g/s
            
            mdot_Air = mdot_O2/massFraction_O2inAir 
            
            eps_voltage = V/E_thermo
            eps_fuel = 1.0 # Assume for aircraft no fuel will be wasted, recycling injector?
            eps_total = eps_thermo * eps_voltage * eps_fuel
            
            powerRate = V*j
            
            if powerRate_prev < powerRate:
                j_max = j
                powerRate_prev = powerRate
        
        outputs['j_max'] = j_max

class PEMRatedPowerAnalysis(ExplicitComponent):
    """
    This is a model for sizing SOFC fuel cells based on the book "Fuel Cell Fundementals" by O'Hayre et. al. (2016).   

    Inputs
    ------
    j_max : float
        Current density that maximizes power output
        (scalar, A/cm**2)
    pressure : float
        Ambient pressure
        (scalar, atmospheres)
    temperature : float
        Ambient temperature
        (scalar, Kelvin)
    diffusivity_O2N2 : float
        Binary diffusion coefficient for oxygen and nitrogen, comes from previous model
        (scalar, m**2/s)
    diffusivity_H2H2O : float
        Binary diffusion coefficient for hydrogen and water, comes from previous model
        (scalar, m**2/s)
    diffusivity_O2H2O : float
        Binary diffusion coefficient for oxygen and water, comes from previous model
        (scalar, m**2/s)
    p_SAT : float
        Vapor saturation pressure, comes from previous model
        (scalar, Pa)
    eps_thermo : float
        Max theoretical efficiency of the fuel cell, comes from previous model
        (scalar, dimensionless)

    Outputs
    -------
    ratedPower : float
        The maximum output power of the fuel cell
        (scalar, W)

    Options
    -------
    j_L : float
        Limit current density, primarily driven by the thickness of the cathode
        (default 2.0, A/cm**2)
    A : float
        Mass coefficient for the area based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 0.5, kg/m**2)
    B : float   
        Mass coefficient for the rated power based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 15.0, kg/W)
    eta_dcdc : float
        Conversion efficiency of the expected DC-DC converter.  The heat from 
        this conversion is included in the usable heat output.
        (default 0.9, dimensionless)
    t_M : float
        Membrane thickness for the electrolyte passing material [m]
        (default 20e-6)
    t_A : float
        Annode thickness [m]
        (default 350e-6)
    t_C : float
        Cathode thickness [m]
        (default 350e-6)
    E_thermo : float
        Thermodynamic voltage, theoretical value that probably should not change [V]
        ( default 1.06 )     
    D_lam : float   
        Water diffusivity in Nafion [m**2/s]
        ( default 100e3 )    
    alpha : float       
        Transfer coefficient, ranges from 0.2 to 0.5
        ( default 0.5 )      
    j0 : float          
        Exchange current density [A/cm**2]
        ( default 0.1 )      
    eps : float         
        Porosity of the electrodes
        ( default 0.4 )      
    tau : float         
        Tortuosity of the electrodes, ranges from 1.5 to 10
        ( default 1.5 )      
    R : float           
        Gas constant [J/(mol*K)]
        ( default 8.314 )    
    F : float           
        Faraday constant [C/mol]
        ( default 96485.34 ) 
    x_H2 : float        
        Hydrogen mole fraction in the fuel
        ( default 1.0 )    
    x_O2 : float        
        Oxygen mole fraction
        ( default 0.19 )    
    x_H2O : float        
        Water mole fraction
        ( default 0.1 )    

    """

    def initialize(self):
        # Very likely to change:
        self.options.declare("j_L"         , default = 2.0       , desc = "Limit currrent density [A/cm**2]")
        self.options.declare("A"           , default = 0.5       , desc = "Mass coefficient for area [kg/m**2]")
        self.options.declare("B"           , default = 15.0      , desc = "Mass coefficient for rated power [kg/W]")
        self.options.declare("eta_dcdc"    , default = 0.9       , desc = "Limit currrent density [A/cm**2]")

        # Likely to change:
        self.options.declare("t_M"         , default = 20e-6     , desc = "Membrane thickness [m]")
        self.options.declare("t_A"         , default = 350e-6    , desc = "Annode thickness [m]")
        self.options.declare("t_C"         , default = 350e-6    , desc = "Cathode thickness [m]")
        
        # May Change:
        self.options.declare("E_thermo"    , default = 1.06      , desc = "Thermodynamic voltage [V]")
        self.options.declare("D_lam"       , default = 3.81e-6 * 10000 , desc = "Water diffusivity in Nafion [m**2/s]")
        self.options.declare("alpha"       , default = 0.5       , desc = "Transfer coefficient")                    # Range: 0.2-0.5
        self.options.declare("j0"          , default = 0.1       , desc = "Exchange current density [A/cm**2]")
        self.options.declare("eps"         , default = 0.4       , desc = "Porosity")                                # Range: 0.4
        self.options.declare("tau"         , default = 1.5       , desc = "Tortuosity")                              # Range: 1.5-10
        
        # Should not change
        self.options.declare("R"           , default = 8.314     , desc = "Gas constant [J/(mol*K)]")
        self.options.declare("F"           , default = 96485.34  , desc = "Faraday constant [C/mol]")
        self.options.declare("x_H2"        , default = 1.0       , desc = "Hydrogen fuel mole fraction")
        self.options.declare("x_O2"        , default = 0.19      , desc = "Oxygen mole fraction")
        self.options.declare("x_H2O"       , default = 0.1       , desc = "Water mole fraction")



    def setup(self):
        # self.add_input("ratedPower"       , units="W"       , desc = "Rated Power")
        self.add_input("j_max"            , units="A/cm**2" , desc = "Fuel cell current density")
        self.add_input("pressure"         , units="atm"     , desc = "Fuel cell pressure")
        self.add_input("temperature"      , units="K"       , desc = "Fuel cell temperature")
        self.add_input("diffusivity_O2N2" , units="m**2/s" , desc = "Diffusivity of oxygen and nitrogen")
        self.add_input("diffusivity_H2H2O", units="m**2/s" , desc = "Diffusivity of hydrogen and water")
        self.add_input("diffusivity_O2H2O", units="m**2/s" , desc = "Diffusivity of oxygen and water")
        self.add_input("p_SAT"            , units="Pa"     , desc = "Vapor saturation pressure")
        self.add_input("eps_thermo"       ,                   desc = "Max theoretical thermo efficiency")
        self.add_input('area'             , units = "m**2" , desc = "Fuel cell area")

        self.add_output('ratedPower', units = "W"   , desc = "Fuel cell rated power")
        # self.add_output('area', units = "m**2" , desc = "Fuel cell area")

        self.declare_partials('*', '*', method='cs')

    def compute(self, inputs, outputs):
        j_max      = inputs["j_max"]
        # ratedPower = inputs["ratedPower"]
        p          = inputs["pressure"]
        T          = inputs["temperature"]
        D_ij_O2N2  = inputs["diffusivity_O2N2"]
        D_ij_H2H2O = inputs["diffusivity_H2H2O"]
        D_ij_O2H2O = inputs["diffusivity_O2H2O"]
        eps_thermo = inputs["eps_thermo"]
        p_SAT      = inputs["p_SAT"]
        area       = inputs["area"]

        j_L        = self.options["j_L"]
        t_M        = self.options["t_M"]
        t_A        = self.options["t_A"]
        t_C        = self.options["t_C"]
        E_thermo   = self.options["E_thermo"]
        D_lam      = self.options["D_lam"]
        alpha      = self.options["alpha"]
        j0         = self.options["j0"]
        eps        = self.options["eps"]
        tau        = self.options["tau"]
        R          = self.options["R"]
        F          = self.options["F"]
        x_H2       = self.options["x_H2"]
        x_O2       = self.options["x_O2"]
        x_H2O      = self.options["x_H2O"]
        eta_dcdc   = self.options["eta_dcdc"]
        A          = self.options["A"]
        B          = self.options["B"]

        D_eff_O2N2  = eps ** tau * D_ij_O2N2
        D_eff_H2H2O = eps ** tau * D_ij_H2H2O
        D_eff_O2H2O = eps ** tau * D_ij_O2H2O

        p_in_atms = p
        p_of_atm = 101325
        p_C = p_in_atms * p_of_atm
        p_A = p_in_atms * p_of_atm
        
        j = j_max

        a11 = 4.4 + 14 * (p_A / p_SAT) * (t_A * ( j*10000 * R * T )/(2*F*p_A*D_eff_H2H2O))
        a12 = 1.0
        b1  = 14 * (p_A / p_SAT) * x_H2O
        
        K = t_C * j*10000 * R * T / (4 * F * p_C * D_eff_O2H2O)
        pRat = p_C/p_SAT
        a21 = 4.4 + (4*pRat*K)
        a22 = np.exp(0.000598 * (j*10000/10000)*(t_M*100)/(D_lam/10000))
        b2  = 10.0 + 4*pRat*(x_H2O + K)
        
        alphaStar = (b1 - a12*b2/a22) / (a11-a12*a21/a22)
        C         = (b2-a21*alphaStar)/a22

        z = np.linspace(0,t_M*100,10000)
        lam = 4.4*alphaStar + C*np.exp(0.000598 * (j)*(z)/(D_lam/10000))
        sigma = (0.005193*lam - 0.003261)*np.exp(1268*(1/303-1/T))
        integrand = 1/sigma
        dz = z[1]-z[0]
        A_PEMFC=np.sum(dz*integrand)/10000

        eta_ohmic = j * 1e4 * A_PEMFC

        cr = x_O2*p_in_atms*p_of_atm/ R/T
        t_C = 4 * F * D_eff_O2N2 / j_L * cr/10000
        f_j = j/j_L
        if j == 0:
            eta_cathode = 0
        elif f_j>=1:
            eta_cathode = E_thermo
        else:
            eta_cathode =  R * T / (4 * alpha * F) * np.log( f_j*(4*F*D_eff_O2N2*p_of_atm/(t_C*R*T)) /(j0*10000*(1-f_j)))
        
        V = E_thermo - max([eta_ohmic,0]) - max([eta_cathode,0])
        
        n_H2 = 2  # H2 reaction rejects 2 electrons
        n_O2 = 4  # O2 reaction accepts 4 electrons
        
        molarMass_H2 = 2.016
        molarMass_O2 = 15.999
        massFraction_O2inAir = .2313333 # air is 23% oxygen by mass

        J_H2 = j/(n_H2*F)  # mol/s
        mdot_H2 = J_H2*molarMass_H2 # g/s
        
        J_O2 = j/(n_O2*F)  # mol/s
        mdot_O2 = J_O2*molarMass_O2 # g/s
        
        mdot_Air = mdot_O2/massFraction_O2inAir 
        
        eps_voltage = V/E_thermo
        eps_fuel = 1.0 # Assume for aircraft no fuel will be wasted, recycling injector?
        eps_total = eps_thermo * eps_voltage * eps_fuel
        
        powerRate = V*j
        powerRate_ideal = powerRate/eps_total
        heatRate = powerRate_ideal - powerRate

        ratedPower = (V*j_max*10000) * area * eta_dcdc
        outputs['ratedPower'] = ratedPower

        # area = ratedPower / eta_dcdc / (V*j_max) / 10000
        # usablePower = powerRate * area *10000 * eta_dcdc
        # mass = A*area + B*usablePower/1000
        # outputs['mass'] = mass
        # outputs['area'] = area


class PEMAnalysis(ExplicitComponent):
    """
    This is a model for analysis of SOFC fuel cells based on the book "Fuel Cell Fundementals" by O'Hayre et. al. (2016).   


    Inputs
    ------
    pressure : float
        Operating pressure of the fuel cell.  This model does not account
        for a compressor to rais the operating pressure from ambient.
        (scalar, atmospheres)
    temperature : float
        Operating temperature of the fuel cell.
        (scalar, Kelvin)
    ratedPower : float
        Rated power of the fuel cell after DC-DC conversion
        (scalar, W)
    throttle : float
        Engine throttle. Scales current density based on the internally 
        computed maximum current density value.  Produces 100% of rated 
        power at throttle = 1.  Should be in range 0 to 1
        (vector, dimensionless)
    j_max : float
        Current density that maximizes power output
        (scalar, A/cm**2)
    diffusivity_O2N2 : float
        Binary diffusion coefficient for oxygen and nitrogen, comes from previous model
        (scalar, m**2/s)
    diffusivity_H2H2O : float
        Binary diffusion coefficient for hydrogen and water, comes from previous model
        (scalar, m**2/s)
    diffusivity_O2H2O : float
        Binary diffusion coefficient for oxygen and water, comes from previous model
        (scalar, m**2/s)
    p_SAT : float
        Vapor saturation pressure, comes from previous model
        (scalar, Pa)
    eps_thermo : float
        Max theoretical efficiency of the fuel cell, comes from previous model
        (scalar, dimensionless)
    area : float
        Working area of the fuel cell
        (scalar, m**2)

    Outputs
    -------
    mdot_H2 : float
        Mass consumption of hydrogen, ie fuel flow
        (vector, kg/s)
    mdot_O2 : float
        Mass consumption of oxygen, sets inlet requirements
        (vector, kg/s)
    mdot_Air : float
        Mass consumption of air based on the mass fraction of oxygen
        (vector, kg/s) 
    eps_total : float
        Fuel cell efficiency
        (vector, dimensionless)
    power : float
        Electrical power generated by the fuel cell
        (vector, Watts)
    usablePower : float
        Power available after DC-DC conversion
        (vector, Watts)
    usableHeat : float
        Heat generated by the fuel cell and the DC-DC converter
        (vector, Watts)
    heat : float
        Heat generated by the fuel cell 
        (vector, Watts)

    Options
    -------
    num_nodes : int
        Number of analysis points to run (sets vec length; default 1)
    j_L : float
        Limit current density, primarily driven by the thickness of the cathode
        (default 2.0, A/cm**2)
    A : float
        Mass coefficient for the area based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 0.5, kg/m**2)
    B : float   
        Mass coefficient for the rated power based contribution.  The default
        value is based only on a single bus engine and should not be 
        relied on for real designs.  Mass prediction attempts to do both
        fuel cell components, along with Balance of Plant, however
        a compressor that raises ambient pressure is not included.
        (default 15.0, kg/W)
    eta_dcdc : float
        Conversion efficiency of the expected DC-DC converter.  The heat from 
        this conversion is included in the usable heat output.
        (default 0.9, dimensionless)
    t_M : float
        Membrane thickness for the electrolyte passing material [m]
        (default 20e-6)
    t_A : float
        Annode thickness [m]
        (default 350e-6)
    t_C : float
        Cathode thickness [m]
        (default 350e-6)
    E_thermo : float
        Thermodynamic voltage, theoretical value that probably should not change [V]
        ( default 1.06 )     
    D_lam : float   
        Water diffusivity in Nafion [m**2/s]
        ( default 100e3 )    
    alpha : float       
        Transfer coefficient, ranges from 0.2 to 0.5
        ( default 0.5 )      
    j0 : float          
        Exchange current density [A/cm**2]
        ( default 0.1 )      
    eps : float         
        Porosity of the electrodes
        ( default 0.4 )      
    tau : float         
        Tortuosity of the electrodes, ranges from 1.5 to 10
        ( default 1.5 )      
    R : float           
        Gas constant [J/(mol*K)]
        ( default 8.314 )    
    F : float           
        Faraday constant [C/mol]
        ( default 96485.34 ) 
    x_H2 : float        
        Hydrogen mole fraction in the fuel
        ( default 1.0 )    
    x_O2 : float        
        Oxygen mole fraction
        ( default 0.19 )    
    x_H2O : float        
        Water mole fraction
        ( default 0.1 )    

    """

    def initialize(self):
        self.options.declare("num_nodes", default=1, desc = "Number of flight/control conditions")

        # Very likely to change:
        self.options.declare("j_L"         , default = 2.0       , desc = "Limit currrent density [A/cm**2]")
        self.options.declare("A"           , default = 0.5       , desc = "Mass coefficient for area [kg/m**2]")
        self.options.declare("B"           , default = 15.0      , desc = "Mass coefficient for rated power [kg/W]")
        self.options.declare("eta_dcdc"    , default = 0.9       , desc = "Limit currrent density [A/cm**2]")

        # Likely to change:
        self.options.declare("t_M"         , default = 20e-6     , desc = "Membrane thickness [m]")
        self.options.declare("t_A"         , default = 350e-6    , desc = "Annode thickness [m]")
        self.options.declare("t_C"         , default = 350e-6    , desc = "Cathode thickness [m]")
        
        # May Change:
        self.options.declare("E_thermo"    , default = 1.06      , desc = "Thermodynamic voltage [V]")
        self.options.declare("D_lam"       , default = 3.81e-6 * 10000 , desc = "Water diffusivity in Nafion [m**2/s]")
        self.options.declare("alpha"       , default = 0.5       , desc = "Transfer coefficient")                    # Range: 0.2-0.5
        self.options.declare("j0"          , default = 0.1       , desc = "Exchange current density [A/cm**2]")
        self.options.declare("eps"         , default = 0.4       , desc = "Porosity")                                # Range: 0.4
        self.options.declare("tau"         , default = 1.5       , desc = "Tortuosity")                              # Range: 1.5-10
        
        # Should not change
        self.options.declare("R"           , default = 8.314     , desc = "Gas constant [J/(mol*K)]")
        self.options.declare("F"           , default = 96485.34  , desc = "Faraday constant [C/mol]")
        self.options.declare("x_H2"        , default = 1.0       , desc = "Hydrogen fuel mole fraction")
        self.options.declare("x_O2"        , default = 0.19      , desc = "Oxygen mole fraction")
        self.options.declare("x_H2O"       , default = 0.1       , desc = "Water mole fraction")

    def setup(self):
        nn = self.options["num_nodes"]
        # self.add_input("ratedPower"       , units="W"       , desc = "Rated Power")
        self.add_input("throttle"         ,                   desc = "Throttle input (Fractional)", shape=(nn,))
        self.add_input("j_max"            , units="A/cm**2" , desc = "Fuel cell current density")
        self.add_input("pressure"         , units="atm"     , desc = "Fuel cell pressure")
        self.add_input("temperature"      , units="K"       , desc = "Fuel cell temperature")
        self.add_input("diffusivity_O2N2" , units="m**2/s" , desc = "Diffusivity of oxygen and nitrogen")
        self.add_input("diffusivity_H2H2O", units="m**2/s" , desc = "Diffusivity of hydrogen and water")
        self.add_input("diffusivity_O2H2O", units="m**2/s" , desc = "Diffusivity of oxygen and water")
        self.add_input("p_SAT"            , units="Pa"     , desc = "Vapor saturation pressure")
        self.add_input("eps_thermo"       ,                   desc = "Max theoretical thermo efficiency")
        self.add_input('area'             , units = "m**2"  , desc = "Fuel cell voltage")

        self.add_output('mdot_H2'     , units = "kg/s" , desc = "Mass consumption of hydrogen"                            , shape=(nn,))
        self.add_output('mdot_O2'     , units = "kg/s" , desc = "Mass consumption of oxygen"                              , shape=(nn,))
        self.add_output('mdot_Air'    , units = "kg/s" , desc = "Mass consumption of air"                                 , shape=(nn,))
        self.add_output('eps_total'   ,                  desc = "Total fuel cell efficiency"                              , shape=(nn,))
        self.add_output('power'       , units = "W"    , desc = "Electrical power generated by the fuel cell"             , shape=(nn,))
        self.add_output('usablePower' , units = "W"    , desc = "Power available after DC-DC conversion"                  , shape=(nn,))
        self.add_output('usableHeat'  , units = "W"    , desc = "Heat generated by the fuel cell and the DC-DC converter" , shape=(nn,))
        self.add_output('heat'        , units = "W"    , desc = "Heat generated by the fuel cell"                         , shape=(nn,))

        self.declare_partials('*', '*', method='cs')

    def compute(self, inputs, outputs):
        throttle   = inputs["throttle"]
        j_max      = inputs["j_max"]
        # ratedPower = inputs["ratedPower"]
        p          = inputs["pressure"]
        T          = inputs["temperature"]
        D_ij_O2N2  = inputs["diffusivity_O2N2"]
        D_ij_H2H2O = inputs["diffusivity_H2H2O"]
        D_ij_O2H2O = inputs["diffusivity_O2H2O"]
        eps_thermo = inputs["eps_thermo"]
        p_SAT      = inputs["p_SAT"]
        area      = inputs["area"]

        j_L        = self.options["j_L"]
        t_M        = self.options["t_M"]
        t_A        = self.options["t_A"]
        t_C        = self.options["t_C"]
        E_thermo   = self.options["E_thermo"]
        D_lam      = self.options["D_lam"]
        alpha      = self.options["alpha"]
        j0         = self.options["j0"]
        eps        = self.options["eps"]
        tau        = self.options["tau"]
        R          = self.options["R"]
        F          = self.options["F"]
        x_H2       = self.options["x_H2"]
        x_O2       = self.options["x_O2"]
        x_H2O      = self.options["x_H2O"]
        eta_dcdc   = self.options["eta_dcdc"]
        A          = self.options["A"]
        B          = self.options["B"]

        D_eff_O2N2  = eps ** tau * D_ij_O2N2
        D_eff_H2H2O = eps ** tau * D_ij_H2H2O
        D_eff_O2H2O = eps ** tau * D_ij_O2H2O

        p_in_atms = p
        p_of_atm = 101325
        p_C = p_in_atms * p_of_atm
        p_A = p_in_atms * p_of_atm
    
        jValues = throttle * j_max

        V = np.zeros(len(jValues),dtype=np.complex_)
        for i in range(0,len(jValues)):
            j = jValues[i]

            if j == 0:
                V[i] = 0.0
            else:
                a11 = 4.4 + 14 * (p_A / p_SAT) * (t_A * ( j*10000 * R * T )/(2*F*p_A*D_eff_H2H2O))
                a12 = 1.0
                b1  = 14 * (p_A / p_SAT) * x_H2O
                
                K = t_C * j*10000 * R * T / (4 * F * p_C * D_eff_O2H2O)
                pRat = p_C/p_SAT
                a21 = 4.4 + (4*pRat*K)
                a22 = np.exp(0.000598 * (j*10000/10000)*(t_M*100)/(D_lam/10000))
                b2  = 10.0 + 4*pRat*(x_H2O + K)
                
                alphaStar = (b1 - a12*b2/a22) / (a11-a12*a21/a22)
                C         = (b2-a21*alphaStar)/a22

                z = np.linspace(0,t_M*100,10000)
                lam = 4.4*alphaStar + C*np.exp(0.000598 * (j)*(z)/(D_lam/10000))
                sigma = (0.005193*lam - 0.003261)*np.exp(1268*(1/303-1/T))
                integrand = 1/sigma
                dz = z[1]-z[0]
                A_PEMFC=np.sum(dz*integrand)/10000

                eta_ohmic = j * 1e4 * A_PEMFC

                cr = x_O2*p_in_atms*p_of_atm/ R/T
                t_C = 4 * F * D_eff_O2N2 / j_L * cr/10000
                f_j = j/j_L
                if j == 0:
                    eta_cathode = 0
                elif f_j>=1:
                    eta_cathode = E_thermo
                else:
                    eta_cathode =  R * T / (4 * alpha * F) * np.log( f_j*(4*F*D_eff_O2N2*p_of_atm/(t_C*R*T)) /(j0*10000*(1-f_j)))
                

                V[i] = E_thermo - max([eta_ohmic,0]) - max([eta_cathode,0])

        if np.sum(abs(V.imag)) == 0.0:
            with warnings.catch_warnings():
                warnings.filterwarnings("ignore", message=".*complex")
                V = V.astype('float')

        n_H2 = 2  # H2 reaction rejects 2 electrons
        n_O2 = 4  # O2 reaction accepts 4 electrons
        
        molarMass_H2 = 2.016
        molarMass_O2 = 15.999
        massFraction_O2inAir = .2313333 # air is 23% oxygen by mass

        J_H2 = j/(n_H2*F)  # mol/s
        mdot_H2 = J_H2*molarMass_H2 # g/s
        
        J_O2 = j/(n_O2*F)  # mol/s
        mdot_O2 = J_O2*molarMass_O2 # g/s
        
        mdot_Air = mdot_O2/massFraction_O2inAir 
        
        eps_voltage = V/E_thermo
        eps_fuel = 1.0 # Assume for aircraft no fuel will be wasted, recycling injector?
        eps_total = eps_thermo * eps_voltage * eps_fuel

        powerRate = V*j
        
        heatRate = np.zeros(len(jValues),dtype=np.complex_)
        for i in range(0,len(jValues)):
            j = jValues[i]
            if j == 0:
                heatRate[i] = 0
            else:
                powerRate_ideal = powerRate[i]/eps_total[i]
                heatRate[i] = powerRate_ideal - powerRate[i]

        if np.sum(abs(heatRate.imag)) == 0.0:
            with warnings.catch_warnings():
                warnings.filterwarnings("ignore", message=".*complex")
                heatRate = heatRate.astype('float')

        usablePower = powerRate * area *10000 * eta_dcdc

        # must convert the j values to m**2 and not cm**2
        outputs['mdot_H2']       = mdot_H2   * area * 10000
        outputs['mdot_O2']       = mdot_O2   * area * 10000
        outputs['mdot_Air']      = mdot_Air  * area * 10000
        outputs['eps_total']     = eps_total * eta_dcdc
        outputs['power']         = powerRate * area * 10000
        outputs['usablePower']   = powerRate * area * 10000 * eta_dcdc
        outputs['heat']          = heatRate  * area * 10000
        outputs['usableHeat']    = heatRate  * area * 10000 + (1-eta_dcdc) * powerRate * area * 10000
    

# ==========================================================================================================================================================================================================================================
# Run script
# ==========================================================================================================================================================================================================================================
if __name__ == "__main__":
    import numpy as np
    import openmdao.api as om
    import matplotlib.pyplot as plt

    # Predict rated power
    prob = om.Problem()
    prob.model.add_subsystem('FuelCellModel',FuelCellPEM_RatedPower(), promotes_inputs=["*"], promotes_outputs=["*"])
    prob.setup()
    # prob['throttle']=np.linspace(0,1,11)
    prob['pressure']=1.0
    prob['temperature']=1073
    prob['area'] = 1
    prob.run_model()
    prob.check_partials(compact_print=True, show_only_incorrect=True)
    # Generate N2 diagram
    om.n2(prob, outfile="fuelCellPEM_ratedPower.html", show_browser=True)
    print(prob.get_val('ratedPower',units='W'))


    # Do full analysis
    nn = 11
    prob = om.Problem()
    prob.model.add_subsystem('FuelCellModel',FuelCellPEM(num_nodes=nn), promotes_inputs=["*"], promotes_outputs=["*"])
    prob.setup()
    prob['throttle']=np.linspace(0,1,11)
    prob['pressure']=1.0
    prob['temperature']=1073
    prob['area'] = 10

    prob.run_model()
    prob.check_partials(compact_print=True, show_only_incorrect=True)

    # Generate N2 diagram
    om.n2(prob, outfile="fuelCellPEM.html", show_browser=True)

    print(prob.get_val('usablePower',units="W"))
    print(prob.get_val('usableHeat',units="W"))


